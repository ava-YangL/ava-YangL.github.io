---
title: 树的遍历
date: 2019-03-21 16:48:54
categories: 
- Code
tags:
- 二叉树
- 代码准备
- 春招准备
---
          
### 前言
- 递归的时候，深度优先用栈，广度优先用队列。

### 先序
根节点——左——右的顺序。
#### 递归
```c
void preOrder(Node * node){
	if(node){
	cout<<node->value;
	preOrder(node->left);
	preOrder(node->right);
    }
}
```
<!--more-->
#### 非递归
对于任一结点p:

（1）访问结点P，并将结点P入栈；

（2）判断结点P的左结点是否为空，若为空，则取栈顶元素并进行出栈操作，并将栈顶元素的右结点置为当前P，重复（1）；若不为空，则将P的左结点置为当前P；

（3）直到P为NULL并且栈为空，则遍历结束。
```c
void preOrder(Node * node){
    if(node==NULL) return;
    stack<Node*> nodestack;
    Node * p=node;
    while( p!=NULL||!nodestack.empty()){
        while(p!=NULL){
            cout<<p->value<<endl;
            nodestack.push(p);
            p=p->next;
        }
        if(!nodestack.empty()){
            p=nodestack.top();
            nodestack.pop();
            p=p->right;
        }
    }
	
}
```

### 中序

可参考牛客的这位朋友的图：
<div style="width: 600px; margin: auto">![avater](1.png)</div>
#### 递归
```c
void inOrder(Node * node){
	if(node){
	  preOrder(node->left);
	  cout<<node->value;
	  preOrder(node->right);
    }
}
```
#### 非递归
  (1）若P的左结点不为空，则将P入栈并将P的左结点置为当前P，重复这个操作；
 
 （2）若P的左结点为NULL，则取栈顶元素并进行出栈操作，访问该栈顶元素，然后将栈顶元素的右结点置为当前结点P；

 （3）直到P为NULL并且栈为空，则遍历结束

```c
void inOrder(Node * node){
	if(node==NULL) return ;
	stack<Node *> nodestack;
	Node * p=node;
	while(p!=NULL || !nodestack.empty()){
	  while(p!=NULL){
	     nodestack.push(p);
	     p=p->left;
	  }
	  if(!nodestack.empty()){
         p=nodestack.top();
         nodestack.pop();
         cout<<p->value;
         p=p->right;
	  }
    }
}

```
### 后序
#### 递归
```c
void postOrder(Node * node){
	if(node){
	preOrder(node->left);
	preOrder(node->right);
	cout<<node->value;
    }
}

```
#### 非递归
对于任一结点P：

（1）将结点P入栈；

（2）如果结点P的左结点和右结点都为NULL或者P的左结点和右结点都已经被访问过，则访问P结点；

（3）若不满足（2）则将P的右结点和左结点依次入栈，重复（2）；

（4）直到栈为空，则遍历结束。

```c
	/*二叉树后续遍历非递归实现*/
	void postOrder_1(BinaryTreeNode* Root)
	{
		if (Root == NULL)
			return;
		stack<BinaryTreeNode*> nodeStack;
		BinaryTreeNode* cur = NULL;
		BinaryTreeNode* pre = NULL;
		nodeStack.push(Root);
		while (!nodeStack.empty())
		{
			cur = nodeStack.top();
			if ((cur->left == NULL&&cur->right == NULL) || (pre != NULL && (pre == cur->left || pre == cur->right)))
			{
				cout << cur->val << " ";
				nodeStack.pop();
				pre = cur;
			}
			else
			{
				if (cur->right != NULL)
					nodeStack.push(cur->right);
				if (cur->left != NULL)
					nodeStack.push(cur->left);
			}
		}

--------------------- 
作者：YF_Li123 
来源：CSDN 
原文：https://blog.csdn.net/YF_Li123/article/details/70311833 
版权声明：本文为博主原创文章，转载请附上博文链接！
```


https://blog.csdn.net/YF_Li123/article/details/70311833