---
title: 牛客
date: 2019-03-28 21:47:04
categories: 
- Code
tags:
- 牛客
---
今天也要加油鸭。

<!--more-->
#### 序列化和反序列化二叉树
这个破题，整理一下知识点的话，（讲道理我不知道我做的对不对。。。）
- string可以直接+= 来在后面补充
- to_string函数可以转换为字符串，头文件就是string
- char* ans=new char[res.length()+1]; .length()就是求距离呀。
- 字符串的结束是'\0'
- char星的[i],可以直接赋值给string 的[i]
- char星可以直接cout
- 指针取值是 星（）

```c
/*
struct TreeNode {
    int val;
    struct TreeNode *left;
    struct TreeNode *right;
    TreeNode(int x) :
            val(x), left(NULL), right(NULL) {
    }
};
*/
class Solution {
public:
    void sehelp(TreeNode *root,string &res){
        if(root==NULL)
        {
            res+="#";
            return;
        }
        else{
            res+=to_string(root->val);
            res+=',';
        }
        sehelp(root->left,res);
        sehelp(root->right,res);
    }

    char* Serialize(TreeNode *root) {
        if(root==NULL) return NULL;
        string res;
        sehelp(root,res);
        char* ans=new char[res.length()+1];
        int aaaaa=res.length();
        int i;
        for(i=0; i<aaaaa; i++)
            ans[i]=res[i];
        res[i]='\0';
        
        return ans;     
    }

    TreeNode* dehelp(char *&str){
        if(*str=='#')
        {
            str++;
            return NULL;
        }
        int num=0;
        while(*str!='\0' && *str!=',')
        {
            num=num*10+(*str-'0');
            str++;
        }
        //TreeNode* root=new TreeNode((*str)-'0');
        TreeNode* root=new TreeNode(num);
        if(*str=='\0')
           return root;
        str++;
        root->left=dehelp(str);
        root->right=dehelp(str);
        return root;
    }
    TreeNode* Deserialize(char *str) {
        if(str==NULL)
            return NULL;
       TreeNode * res=dehelp(str);
       return res;
    }
};


```




#### 35 数组的逆序对
采用归并排序的思想，差分成一个一个的小元素，再是两个两个的小元素去处理。递归用了start和end，和类似二分的思想,还要注意的是copy数组的辅助排序作用。
```c
class Solution {
public:
    int InversePairs(vector<int> data) {
        if(data.size()<=1) return 0;
        vector<int>copy(data.size(),0); //建立一个全是0的copy数组
        return sortn(data,copy,0,data.size()-1); //start和end进行改变递归
       
    }
    int sortn(vector<int> &data,vector<int> &copy,int start,int end){//data一开始没加引用  //一定要加引用啊，因为data copy的改变需要一直作用啊
        //拆分成n个元素，即每个小堆里面只有1个元素的时候，直接copy赋值为data就行
        if(start==end)
        {
            copy[start]=copy[end];
            return 0;
        }
        else{
            int mid=start+(end-start)/2;
            int leftnum=sortn(data,copy,start,mid)%1000000007;  //左边情况
            int rightnum=sortn(data,copy,mid+1,end)%1000000007; //右边情况 后面加上两组合并情况
            int i=mid; //左
            int j=end; //右
            int k=end; //copy的末尾
            int count=0;
            while(i>=start && j>=mid+1){
                if(data[i]>data[j]){
                    //count++;//啊这里可不是count++
                    count+=(j-mid);
                    count=count%1000000007;
                    copy[k--]=data[i--];
                }else{
                    copy[k--]=data[j--];
                }
            }
            //对没复制完生的部分的处理
            for(;i>=start;)
                copy[k--]=data[i--];
            for(;j>=mid+1;)
                copy[k--]=data[j--];
            //要对data操作赋值啊
            //for(int i=0;i<data.size();i++) 这里！！！！ data要重新排序啊
            for(int i=start;i<=end;i++) //注意这里 不是0-size-1  而是start->end
                data[i]=copy[i];
            return (count+leftnum+rightnum)%1000000007;          
        }  
    }
};
```

#### 36 平衡二叉树
##### ANS1，自己写的在别人的基础上改的，我的代码多了好多冗余啊。

```c
class Solution {
public:
    
    int dfs(TreeNode* pToot){
        
        if(pToot==NULL)
            return 0;
        /*
        if(pToot->left==NULL && pToot->right==NULL)
            return 1;
            */
        return 1+max(dfs(pToot->left),dfs(pToot->right));
        
    }
    /*
    bool getans(TreeNode* pRoot){
        if(pRoot==NULL)
            return true;
        if(abs(dfs(pRoot->left)-dfs(pRoot->right))>1 )
           return false;
        else
            if(getans(pRoot->left)&&(getans(pRoot->right)))
           return true;
    }*/
    
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if (pRoot==NULL) return true;
        bool ans;
        ans=IsBalanced_Solution(pRoot->left)&&IsBalanced_Solution(pRoot->right)&&(abs(dfs(pRoot->left)-dfs(pRoot->right))<=1);
        return ans;
        

    }
};



```
ANS2: 这个方法子树不是就停止遍历了,快一些
```c
class Solution {
public:
    
    int dfs(TreeNode* pToot){
        if(pToot==NULL)
            return 0;
        int left=dfs(pToot->left);
        if (left==-1)
            return -1;
        int right=dfs(pToot->right);
        if (right==-1)
            return -1;
        if(abs(left-right)>1)
            return -1;
        return 1+max(dfs(pToot->left),dfs(pToot->right));
        
        
    }
    
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(dfs(pRoot)==-1)
            return false;
        else
            return true;
    }
};



```