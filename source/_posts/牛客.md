---
title: 牛客
date: 2019-03-28 21:47:04
categories: 
- Code
tags:
- 牛客
---
今天也要加油鸭。

<!--more-->

#### 35 数组的逆序对
采用归并排序的思想，差分成一个一个的小元素，再是两个两个的小元素去处理。递归用了start和end，和类似二分的思想,还要注意的是copy数组的辅助排序作用。
```c
class Solution {
public:
    int InversePairs(vector<int> data) {
        if(data.size()<=1) return 0;
        vector<int>copy(data.size(),0); //建立一个全是0的copy数组
        return sortn(data,copy,0,data.size()-1); //start和end进行改变递归
       
    }
    int sortn(vector<int> &data,vector<int> &copy,int start,int end){//data一开始没加引用  //一定要加引用啊，因为data copy的改变需要一直作用啊
        //拆分成n个元素，即每个小堆里面只有1个元素的时候，直接copy赋值为data就行
        if(start==end)
        {
            copy[start]=copy[end];
            return 0;
        }
        else{
            int mid=start+(end-start)/2;
            int leftnum=sortn(data,copy,start,mid)%1000000007;  //左边情况
            int rightnum=sortn(data,copy,mid+1,end)%1000000007; //右边情况 后面加上两组合并情况
            int i=mid; //左
            int j=end; //右
            int k=end; //copy的末尾
            int count=0;
            while(i>=start && j>=mid+1){
                if(data[i]>data[j]){
                    //count++;//啊这里可不是count++
                    count+=(j-mid);
                    count=count%1000000007;
                    copy[k--]=data[i--];
                }else{
                    copy[k--]=data[j--];
                }
            }
            //对没复制完生的部分的处理
            for(;i>=start;)
                copy[k--]=data[i--];
            for(;j>=mid+1;)
                copy[k--]=data[j--];
            //要对data操作赋值啊
            //for(int i=0;i<data.size();i++) 这里！！！！ data要重新排序啊
            for(int i=start;i<=end;i++) //注意这里 不是0-size-1  而是start->end
                data[i]=copy[i];
            return (count+leftnum+rightnum)%1000000007;          
        }  
    }
};
```

#### 36 平衡二叉树
##### ANS1，自己写的在别人的基础上改的，我的代码多了好多冗余啊。

```c
class Solution {
public:
    
    int dfs(TreeNode* pToot){
        
        if(pToot==NULL)
            return 0;
        /*
        if(pToot->left==NULL && pToot->right==NULL)
            return 1;
            */
        return 1+max(dfs(pToot->left),dfs(pToot->right));
        
    }
    /*
    bool getans(TreeNode* pRoot){
        if(pRoot==NULL)
            return true;
        if(abs(dfs(pRoot->left)-dfs(pRoot->right))>1 )
           return false;
        else
            if(getans(pRoot->left)&&(getans(pRoot->right)))
           return true;
    }*/
    
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if (pRoot==NULL) return true;
        bool ans;
        ans=IsBalanced_Solution(pRoot->left)&&IsBalanced_Solution(pRoot->right)&&(abs(dfs(pRoot->left)-dfs(pRoot->right))<=1);
        return ans;
        

    }
};



```
ANS2: 这个方法子树不是就停止遍历了,快一些
```c
class Solution {
public:
    
    int dfs(TreeNode* pToot){
        if(pToot==NULL)
            return 0;
        int left=dfs(pToot->left);
        if (left==-1)
            return -1;
        int right=dfs(pToot->right);
        if (right==-1)
            return -1;
        if(abs(left-right)>1)
            return -1;
        return 1+max(dfs(pToot->left),dfs(pToot->right));
        
        
    }
    
    bool IsBalanced_Solution(TreeNode* pRoot) {
        if(dfs(pRoot)==-1)
            return false;
        else
            return true;
    }
};



```