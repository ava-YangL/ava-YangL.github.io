---
title: 排序算法总结
date: 2019-03-28 21:34:41
categories: 
- Code
tags:
- 排序算法总结
- 基础知识 
---

#### 1 总结：
时间一样的：桶(n)、基数(n)、归并(nlogn)、堆(nlogn)、选择排序(n^2)
不稳定的：桶、快速、堆、希尔、选择
![avater](1.jpg)


#### 归并算法：


#### Top中的快排改进
https://bbs.csdn.net/topics/391545814
```c
void GetLeastNumbers(int* input, int n, int* output, int k)
{
    if (input == NULL || output == NULL || k > n || n <= 0 || k <= 0)
        return;
    int start = 0;
    int end = n - 1;
    int index = Partition(input, n, start, end);
    while (index != k - 1)
    {
        if (index > k - 1)
        {
            end = index - 1;
            index = Partition(input, n, start, end);
        }
        else
        {
            start = index + 1;
            index = Partition(input, n, start, end);
        }
    }
    for (int i = 0; i < k; ++i)
        output[i] = input[i];
}
```
再看看具体的代码，时间复杂度是On

（1）有人说 因为每次递归只进入一边，所以实践复杂度为On
（2）有人说 快排必须低轨道logn层，求最小k个树只需要划分几次就可以找到index了
（3)恩，是这个道理。在回复别人的时候突然想通了，快排是必须要向下递归的，而上面这个并不需要递归，而是类似折半。
1+1/2+1/4+1/8+...<2    ，o(2n)=o(n)，所以时间复杂度是o(n)。
 (4) 快排的时间复杂度为啥是Onlogn：根据快排的实现方式，我们可以得出，最多可拆分logn层，因为每次都一分为二，所以2^k=n, k=logn,每一层最多交换n次，所以结果就是O(nlogn)

#### 堆排序复杂度
 https://blog.csdn.net/loveliuzz/article/details/77618530

#### 快速排序


#### 冒泡排序



https://zhuanlan.zhihu.com/p/52884590?utm_source=wechat_session&utm_medium=social&utm_oi=779712987186335744
#### 归并排序